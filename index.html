<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Fiber Optic Fault Locator — Single File</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100vh; }
    .input-panel {
      position: absolute; top: 10px; left: 10px; z-index: 1000;
      background: #fff; padding: 12px; border-radius: 10px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      font-size: 14px; width: 280px; max-width: 85vw;
    }
    .input-panel h3 { margin: 0 0 8px; font-size: 16px; }
    .row { margin: 6px 0; display: grid; grid-template-columns: 1fr; gap: 6px; }
    .row label { font-weight: 600; }
    .row input, .row select { padding: 6px 8px; border-radius: 6px; border: 1px solid #ddd; }
    .row button { padding: 8px 10px; border: none; border-radius: 8px; cursor: pointer; background:#2563eb; color: #fff; font-weight: 600; }
    .hint { font-size: 12px; color: #444; line-height: 1.4; }
    .badge { display:inline-block; padding:2px 6px; border:1px solid #ddd; border-radius:999px; font-size:11px; color:#555; }
  </style>
</head>
<body>
  <div class="input-panel">
    <h3>Fiber Optic Fault Locator <span class="badge">Single‑File</span></h3>
    <div class="row">
      <label>Mulai dari Titik A (opsional)</label>
      <select id="pointA"></select>
    </div>
    <div class="row">
      <label>Jarak putus dari A (meter)</label>
      <input type="number" id="faultDistance" placeholder="misal: 1200" />
      <button id="btnLocate">Cari Titik Putus</button>
    </div>
    <div class="row">
      <div class="hint">
        • File ini bisa langsung jalan di GitHub Pages.<br/>
        • Kamu bisa <b>sematkan KML</b> di bawah (script#kmlData) atau <b>taruh data.kml</b> di repo yang sama — otomatis terbaca.
      </div>
    </div>
  </div>
  <div id="map"></div>

  <!-- Leaflet & toGeoJSON -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/togeojson@0.16.0"></script>

  <!-- =====================
       Opsi 1: KML Embedded
       ---------------------
       Paste isi file KML kamu di antara tag di bawah ini.
       Kalau dibiarkan kosong, script akan otomatis mencoba memuat 'data.kml' via fetch().
       ====================== -->
  <script id="kmlData" type="application/xml">
  <!--
  <?xml version="1.0" encoding="UTF-8"?>
  <kml xmlns="http://www.opengis.net/kml/2.2">
    <Document>
      <Placemark><name>Node A</name><Point><coordinates>112.8800,-7.6300,0</coordinates></Point></Placemark>
      <Placemark><name>Node B</name><Point><coordinates>112.9000,-7.6400,0</coordinates></Point></Placemark>
      <Placemark><name>FO Trunk</name>
        <LineString><coordinates>
          112.8800,-7.6300,0 112.8850,-7.6320,0 112.8900,-7.6350,0 112.9000,-7.6400,0
        </coordinates></LineString>
      </Placemark>
    </Document>
  </kml>
  -->
  </script>

  <script>
    // --- Map init
    const map = L.map('map').setView([-7.63, 112.88], 13);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 20, attribution: '&copy; OpenStreetMap' }).addTo(map);

    let placemarks = [];          // GeoJSON Point features
    let lineCoords = [];          // [[lat,lng], ...] from the first LineString found
    let polyline = null;          // Leaflet polyline layer
    let faultMarker = null;       // Leaflet marker layer

    const selA = document.getElementById('pointA');
    const btnLocate = document.getElementById('btnLocate');
    const inputDist = document.getElementById('faultDistance');

    btnLocate.addEventListener('click', locateFault);

    // Try embedded KML first; if empty, try fetch('data.kml') relative to this page.
    (async function bootstrap() {
      const kmlTag = document.getElementById('kmlData');
      const raw = kmlTag && kmlTag.textContent.trim();
      if (raw && raw.length > 0) {
        loadKmlFromString(raw);
      } else {
        try {
          const res = await fetch('data.kml', { cache: 'no-store' });
          if (!res.ok) throw new Error('data.kml not found');
          const text = await res.text();
          loadKmlFromString(text);
        } catch (e) {
          console.warn('KML tidak ditemukan. Sematkan di <script#kmlData> atau tambahkan data.kml di repo.', e);
        }
      }
    })();

    function loadKmlFromString(kmlText) {
      const parser = new DOMParser();
      const kml = parser.parseFromString(kmlText, 'text/xml');
      const geojson = toGeoJSON.kml(kml);

      // Reset layers/selections if reloaded
      placemarks = []; lineCoords = []; if (polyline) { map.removeLayer(polyline); } if (faultMarker) { map.removeLayer(faultMarker); }
      selA.innerHTML = '';

      geojson.features.forEach((f) => {
        if (f.geometry.type === 'Point') {
          placemarks.push(f);
          const lat = f.geometry.coordinates[1];
          const lng = f.geometry.coordinates[0];
          L.marker([lat, lng]).addTo(map).bindPopup(f.properties.name || 'Point');
          const opt = document.createElement('option');
          opt.value = `${lat},${lng}`; // store coords to avoid name collisions
          opt.text = f.properties.name || `${lat.toFixed(5)}, ${lng.toFixed(5)}`;
          selA.appendChild(opt);
        } else if (f.geometry.type === 'LineString' && lineCoords.length === 0) {
          // pakai LineString pertama yang ditemukan; tambah logika kalau butuh multi-line
          lineCoords = f.geometry.coordinates.map((c) => [c[1], c[0]]);
        }
      });

      if (lineCoords.length) {
        polyline = L.polyline(lineCoords, { color: 'blue', weight: 4 }).addTo(map);
        map.fitBounds(polyline.getBounds(), { padding: [30, 30] });
      }

      // Auto-select first A if exists
      if (selA.options.length > 0) selA.selectedIndex = 0;
    }

    function locateFault() {
      if (!lineCoords.length) { alert('Belum ada LineString di KML.'); return; }

      const faultDist = parseFloat(inputDist.value);
      if (isNaN(faultDist) || faultDist < 0) { alert('Masukkan jarak putus yang valid (meter).'); return; }

      // Tentukan titik start: paling dekat ke Titik A jika dipilih; kalau tidak, pakai indeks 0.
      let startIdx = 0;
      const valA = selA.value;
      if (valA) {
        const [alat, alng] = valA.split(',').map(Number);
        startIdx = closestIndexOnLine([alat, alng], lineCoords);
      }

      // Hitung sepanjang polyline mulai dari startIdx ke depan
      let cumDist = 0;
      for (let i = startIdx + 1; i < lineCoords.length; i++) {
        const p1 = L.latLng(lineCoords[i - 1]);
        const p2 = L.latLng(lineCoords[i]);
        const segDist = p1.distanceTo(p2);
        if (cumDist + segDist >= faultDist) {
          const ratio = (faultDist - cumDist) / segDist;
          const lat = p1.lat + (p2.lat - p1.lat) * ratio;
          const lng = p1.lng + (p2.lng - p1.lng) * ratio;
          if (faultMarker) map.removeLayer(faultMarker);
          faultMarker = L.marker([lat, lng], { title: 'Titik Putus' })
            .addTo(map)
            .bindPopup(`Titik putus di sini (<b>${lat.toFixed(5)}, ${lng.toFixed(5)}</b>)`).openPopup();
          map.panTo([lat, lng]);
          return;
        }
        cumDist += segDist;
      }

      alert('Jarak melebihi panjang jalur dari titik A yang dipilih.');
    }

    function closestIndexOnLine(point, line) {
      // cari indeks vertex paling dekat dengan titik (pendekatan cepat)
      let bestIdx = 0; let bestD = Infinity;
      for (let i = 0; i < line.length; i++) {
        const d = L.latLng(line[i]).distanceTo(L.latLng(point[0], point[1]));
        if (d < bestD) { bestD = d; bestIdx = i; }
      }
      return bestIdx;
    }
  </script>
</body>
</html>
